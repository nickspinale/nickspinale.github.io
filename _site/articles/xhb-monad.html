<!doctype html>
<html>
    <head>

        <title>Nick Spinale - xhb-monad</title>

        <link rel="stylesheet" type="text/css" href="/css/main.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width">
        <meta name="description" content="Personal website of Nick Spinale.">

        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-86175905-1', 'auto');
          ga('send', 'pageview');
        </script>

    </head>
    <body>

        <!-- made up tags used to weaken css associations -->

        <ns-navigation>
            <div id="navigation">
                <h1><a href="/">Nick Spinale</a></h1>
                <div id="navigation-down">
                    <a href="/projects.html">Projects</a>
                    <a href="/articles.html">Articles</a>
                    <a href="/resume.pdf">Resume</a>
                </div>
            </div>
        </ns-navigation>

        <ns-content>
            <div id="content">
                <h1 class="article-title">xhb-monad</h1>
<span class="soft">
    2016-07-22 &mdash; A set of abstraction layers for xhb.
</span>
<hr>
<div class="article-body">
    <p>X11 programming in Haskell has traditionally been done using the <a href="https://hackage.haskell.org/package/X11-1.6.1.2">X11 package</a>. Many of these bindings were written by hand and, due to their reliance on FFI, are susceptible to some threading issues. <a href="https://hackage.haskell.org/package/xhb">xhb</a>, a newer package, provides low-level bindings to X11 based on the same XML as <a href="https://xcb.freedesktop.org/">xcb</a>.</p>
<p>It doesn’t seem as though much has been done with XHB yet. In fact, at the time of writing (Aug 22, 2016), exactly two packages on Hackage depend on xhb. Nevertheless, I believe it hold great promise in the future of X programming in Haskell.</p>
<p>I’ve been working on a set of libraries that allows for layers of abstraction to be staked on top of the low-level xhb bindings. This post will become more fleshed out as I find time to finish up and document the actual libraries, but here’s an overview.</p>
<h2 id="xhb-requests"><a href="https://github.com/nspin/xhb-requests">xhb-requests</a></h2>
<p>(<em>haddock <a href="/xhb-requests">here</a></em>)</p>
<p>Most generated functions in xhb have types similar to those below:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">createWindow ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">CreateWindow</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">grabKeyboard ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">GrabKeyboard</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Receipt</span> <span class="dt">GrabStatus</span>)</code></pre></div>
<p>Those requests which expect responses can wait for them as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getReply ::</span> <span class="dt">Receipt</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">SomeError</span> a)</code></pre></div>
<p>Some functions are a bit different (request parameters don’t live inside a dedicated type, but are passed directly to the function):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">configureWindow ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">WINDOW</span> <span class="ot">-&gt;</span> <span class="dt">ValueParam</span> <span class="dt">Word16</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">queryTextExtents ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">FONTABLE</span> <span class="ot">-&gt;</span> [<span class="dt">CHAR2B</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Receipt</span> <span class="dt">QueryTextExtentsReply</span>)</code></pre></div>
<p>Nevertheless, thanks to disciplined code generation, xhb has a clean and uniform code base. The (in progress) <a href="https://github.com/nspin/xhb-requests">xhb-requests</a> package wraps all of these generated request functions in two classes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Request</span> a <span class="kw">where</span>
<span class="ot">    requestIO ::</span> a <span class="ot">-&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()

<span class="kw">class</span> <span class="dt">RequestWithReply</span> a b <span class="fu">|</span> a <span class="ot">-&gt;</span> b, b <span class="ot">-&gt;</span> a <span class="kw">where</span>
<span class="ot">    requestWithReplyIO ::</span> a <span class="ot">-&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">SomeError</span> b))</code></pre></div>
<p>The instances of this class are generated from the xhb code that is itself generated from XML, which sounds ugly, but it worked quite well. This is the foundation for xhb-monad.</p>
<h2 id="xhb-monad"><a href="https://github.com/nspin/xhb-monad">xhb-monad</a></h2>
<p>(<em>haddock <a href="/xhb-monad">here</a></em>)</p>
<p>This package defines the following class:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> x <span class="ot">=&gt;</span> <span class="dt">XContext</span> x <span class="kw">where</span>
<span class="ot">    request ::</span> <span class="dt">Request</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> x ()
<span class="ot">    requestWithReply ::</span> <span class="dt">RequestWithReply</span> a b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> x (x (<span class="dt">Either</span> <span class="dt">SomeError</span> b))
<span class="ot">    awaitEvent ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> x <span class="dt">SomeEvent</span>

<span class="kw">instance</span> <span class="dt">XContext</span> <span class="dt">IO</span> <span class="kw">where</span>
    request <span class="fu">=</span> requestIO
    requestWithReply <span class="fu">=</span> requestWithReplyIO
    awaitEvent <span class="fu">=</span> waitForEvent</code></pre></div>
<p>and the following monad transformer:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">XContext</span> x, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadX</span> x m <span class="fu">|</span> m <span class="ot">-&gt;</span> x <span class="kw">where</span>
<span class="ot">    liftX ::</span> x a <span class="ot">-&gt;</span> m a
<span class="ot">    askX ::</span> m <span class="dt">Connection</span>
<span class="ot">    catchErrorX ::</span> m a <span class="ot">-&gt;</span> (<span class="dt">SomeError</span> <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a
<span class="ot">    throwErrorX ::</span> <span class="dt">SomeError</span> <span class="ot">-&gt;</span> m a

<span class="kw">newtype</span> <span class="dt">X</span> m a <span class="fu">=</span> <span class="dt">X</span> {<span class="ot"> runX ::</span> <span class="dt">ReaderT</span> <span class="dt">Connection</span> (<span class="dt">ExceptT</span> <span class="dt">SomeError</span> m) a }
    <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadIO</span>, <span class="dt">Typeable</span>)

<span class="kw">instance</span> <span class="dt">XContext</span> x <span class="ot">=&gt;</span> <span class="dt">MonadX</span> x (<span class="dt">X</span> x) <span class="kw">where</span>
    liftX <span class="fu">=</span> <span class="dt">X</span> <span class="fu">.</span> lift <span class="fu">.</span> lift
    askX <span class="fu">=</span> <span class="dt">X</span> ask
    catchErrorX m f <span class="fu">=</span> <span class="dt">X</span> <span class="fu">$</span> catchError (runX m) (runX <span class="fu">.</span> f)
    throwErrorX <span class="fu">=</span> <span class="dt">X</span> <span class="fu">.</span> throwError

<span class="co">--- mtl stuff also</span>
<span class="kw">instance</span> <span class="dt">MonadFoo</span> <span class="dt">Bar</span> <span class="kw">where</span><span class="fu">...</span></code></pre></div>
<p>This abstraction allows for <em>pure</em> X logic. It also lets us isolate unwieldy layers of computation and bits of state in the usual <code>mtl</code> way. xhb-mapping-state is an example of this.</p>
<h2 id="xhb-mapping-state"><a href="https://github.com/nspin/xhb-mapping-state">xhb-mapping-state</a></h2>
<p>(<em>haddock <a href="/xhb-mapping-state">here</a></em>)</p>
<!-- *   [xhb-keysyms](/xhb-keysyms) -->
<p><code>TODO</code></p>
</div>

            </div>
        </ns-content>

    </body>
</html>
